1.

b)

lab6_session/vector_add> /usr/bin/time ./vector_add.v8 > /dev/null
0.15user 0.00system 0:00.15elapsed 98%CPU (0avgtext+0avgdata 1536maxresident)k
0inputs+0outputs (0major+137minor)pagefaults 0swaps

lab6_session/vector_add> /usr/bin/time ./vector_add.v16 > /dev/null
0.30user 0.00system 0:00.31elapsed 99%CPU (0avgtext+0avgdata 1536maxresident)k
0inputs+0outputs (0major+137minor)pagefaults 0swaps

lab6_session/vector_add> /usr/bin/time ./vector_add.v32 > /dev/null
0.61user 0.00system 0:00.61elapsed 99%CPU (0avgtext+0avgdata 1536maxresident)k
0inputs+0outputs (0major+137minor)pagefaults 0swaps

A medida que aumenta el tamaño de los elementos, llenamos el registro vectorial con menos elementos y operamos con menos:

en el caso vector_add.v8, llenamos el reg vectorial con 16 elementos de 8 bits y sumamos de 16 en 16,

en el caso vector_add.v16, llenamos el reg vectorial con 8 elementos de 16 bits y sumamos de 8 en 8, tardando el doble.

c)

lab6_session/vector_add> /usr/bin/time ./vector_add.e8 > /dev/null 
2.65user 0.00system 0:02.67elapsed 99%CPU (0avgtext+0avgdata 1520maxresident)k
0inputs+0outputs (0major+136minor)pagefaults 0swaps

lab6_session/vector_add> /usr/bin/time ./vector_add.e16 > /dev/null
2.62user 0.00system 0:02.64elapsed 99%CPU (0avgtext+0avgdata 1568maxresident)k
0inputs+0outputs (0major+139minor)pagefaults 0swaps

lab6_session/vector_add> /usr/bin/time ./vector_add.e32 > /dev/null
2.64user 0.00system 0:02.65elapsed 99%CPU (0avgtext+0avgdata 1568maxresident)k
0inputs+0outputs (0major+139minor)pagefaults 0swaps

En el caso de los escalares, la diferencia de tiempo no es muy notable. Depende de las instrucciones addb, addw, addl.

2.

a)

lab6_session/vector_add> /usr/bin/time ./vector_add.v8 > /dev/null
0.15user 0.00system 0:00.16elapsed 98%CPU (0avgtext+0avgdata 1536maxresident)k
0inputs+0outputs (0major+137minor)pagefaults 0swaps

lab6_session/vector_add> /usr/bin/time ./vector_add.v16 > /dev/null
0.29user 0.00system 0:00.30elapsed 98%CPU (0avgtext+0avgdata 1552maxresident)k
0inputs+0outputs (0major+138minor)pagefaults 0swaps

lab6_session/vector_add> /usr/bin/time ./vector_add.v32 > /dev/null
0.59user 0.00system 0:00.60elapsed 99%CPU (0avgtext+0avgdata 1536maxresident)k
0inputs+0outputs (0major+137minor)pagefaults 0swaps

Los resultados son muy parecidos a los obtenidos con -O2 ya que optimizar más allá de SIMD...

b)

lab6_session/vector_add> /usr/bin/time ./vector_add.e8 > /dev/null
0.19user 0.00system 0:00.20elapsed 98%CPU (0avgtext+0avgdata 1504maxresident)k
0inputs+0outputs (0major+135minor)pagefaults 0swaps

lab6_session/vector_add> /usr/bin/time ./vector_add.e16 > /dev/null
0.38user 0.00system 0:00.38elapsed 98%CPU (0avgtext+0avgdata 1584maxresident)k
0inputs+0outputs (0major+140minor)pagefaults 0swaps

lab6_session/vector_add> /usr/bin/time ./vector_add.e32 > /dev/null
0.75user 0.00system 0:00.76elapsed 99%CPU (0avgtext+0avgdata 1568maxresident)k
0inputs+0outputs (0major+139minor)pagefaults 0swaps

Con -O3, el compilador hace vectorización y eso aumenta el rendimiento aunque los accesos son no alineados y tardan más que con a)

En ambos casos los tiempos son iguales

